<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebCodecs Node.js - Video Editor</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: system-ui; max-width: 1200px; margin: 20px auto; padding: 20px; background: #f5f5f5; }
    h1 { color: #333; }
    .test { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; background: white; }
    .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
    .success { background: #d4edda; color: #155724; }
    .error { background: #f8d7da; color: #721c24; }
    .pending { background: #fff3cd; color: #856404; }
    button { padding: 10px 20px; font-size: 14px; cursor: pointer; margin: 5px; background: #4CAF50; color: white; border: none; border-radius: 4px; }
    button:hover { background: #45a049; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    canvas { border: 1px solid #ccc; margin: 10px 0; max-width: 100%; }
    .drop-zone {
      border: 3px dashed #ccc;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }
    .drop-zone.dragover { border-color: #4CAF50; background: #f0f8f0; }
    .file-info { margin: 10px 0; padding: 15px; background: #f5f5f5; border-radius: 4px; }
    .file-info table { width: 100%; }
    .file-info td { padding: 5px; }
    .file-info td:first-child { font-weight: bold; width: 150px; }
    pre { background: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 12px; }
    .tabs { display: flex; gap: 5px; margin-bottom: 20px; flex-wrap: wrap; }
    .tab { padding: 10px 20px; cursor: pointer; border: 1px solid #ddd; border-radius: 4px; background: white; }
    .tab.active { background: #4CAF50; color: white; border-color: #4CAF50; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .video-preview { max-width: 100%; border-radius: 8px; }
    .timeline { width: 100%; height: 80px; background: #eee; border-radius: 4px; position: relative; margin: 20px 0; cursor: pointer; overflow: hidden; }
    .timeline-marker { position: absolute; width: 2px; height: 100%; background: red; cursor: ew-resize; z-index: 2; }
    .timeline-preview { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: white; border: 2px solid #333; border-radius: 4px; padding: 5px; display: none; z-index: 10; }
    .timeline-preview canvas { display: block; }
    .timeline-preview-time { text-align: center; font-size: 12px; padding: 5px; background: #333; color: white; }
    .timeline-thumbnails { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; }
    .timeline-thumbnails canvas { flex: 1; opacity: 0.7; }
    .trim-controls { display: flex; gap: 10px; align-items: center; margin: 10px 0; }
    .trim-controls input[type="range"] { flex: 1; }
    .export-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0; }
    .export-options label { display: block; margin-bottom: 5px; font-weight: bold; }
    .export-options select, .export-options input { width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; }
    .thumbnail-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; margin: 10px 0; }
    .thumbnail { border: 2px solid #ddd; border-radius: 4px; cursor: pointer; transition: all 0.2s; }
    .thumbnail:hover { border-color: #4CAF50; transform: scale(1.05); }
    .thumbnail canvas { width: 100%; display: block; }
    .thumbnail-time { text-align: center; padding: 5px; font-size: 12px; background: #f5f5f5; }
  </style>
</head>
<body>
  <h1>üé¨ WebCodecs Node.js - Video Editor</h1>
  <p>Full-featured video editor powered by <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API" target="_blank">WebCodecs API</a> on Node.js</p>

  <div class="tabs">
    <div class="tab active" onclick="switchTab('upload')">üìÅ Upload</div>
    <div class="tab" onclick="switchTab('preview')">üé¨ Preview</div>
    <div class="tab" onclick="switchTab('trim')">‚úÇÔ∏è Trim & Cut</div>
    <div class="tab" onclick="switchTab('export')">üíæ Export</div>
    <div class="tab" onclick="switchTab('info')">‚ÑπÔ∏è Media Info</div>
    <div class="tab" onclick="switchTab('basic')">üß™ Basic Tests</div>
  </div>

  <!-- Upload Tab -->
  <div id="upload-tab" class="tab-content active">
    <div class="test">
      <h2>Upload Video File</h2>
      <div class="drop-zone" id="dropZone">
        <p>üìÅ Drop video file here or click to select</p>
        <p style="font-size: 14px; color: #666;">Supports: MP4, WebM, MKV</p>
      </div>
      <input type="file" id="fileInput" accept="video/*" style="display: none;">
      <div id="upload-status"></div>
    </div>
  </div>

  <!-- Preview Tab -->
  <div id="preview-tab" class="tab-content">
    <div class="test">
      <h2>Video Preview</h2>
      <video id="videoPreview" class="video-preview" controls style="display: none;"></video>
      <canvas id="previewCanvas" width="640" height="480" style="display: none;"></canvas>
      
      <div class="thumbnail-grid" id="thumbnailGrid"></div>
      
      <div style="margin-top: 20px;">
        <button onclick="generateThumbnails()" id="thumbBtn" disabled>Generate Thumbnails</button>
        <button onclick="playPreview()" id="playBtn" disabled>‚ñ∂Ô∏è Play</button>
      </div>
      <div id="preview-status"></div>
    </div>
  </div>

  <!-- Trim & Cut Tab -->
  <div id="trim-tab" class="tab-content">
    <div class="test">
      <h2>Trim & Cut Video</h2>
      
      <div class="timeline" id="timeline">
        <div class="timeline-thumbnails" id="timelineThumbs"></div>
        <div class="timeline-preview" id="timelinePreview">
          <canvas width="160" height="90"></canvas>
          <div class="timeline-preview-time" id="previewTime">0:00</div>
        </div>
        <div class="timeline-marker" id="startMarker" style="left: 0%; background: green;"></div>
        <div class="timeline-marker" id="endMarker" style="left: 100%; background: red;"></div>
      </div>
      
      <div class="trim-controls">
        <label>Start: <input type="range" id="startRange" min="0" max="100" value="0" disabled></label>
        <span id="startTime">0:00</span>
      </div>
      
      <div class="trim-controls">
        <label>End: <input type="range" id="endRange" min="0" max="100" value="100" disabled></label>
        <span id="endTime">0:00</span>
      </div>
      
      <button onclick="trimVideo()" id="trimBtn" disabled>‚úÇÔ∏è Trim Video</button>
      <div id="trim-status"></div>
    </div>
  </div>

  <!-- Export Tab -->
  <div id="export-tab" class="tab-content">
    <div class="test">
      <h2>Export Video</h2>
      
      <div class="export-options">
        <div>
          <label>Codec:</label>
          <select id="exportCodec">
            <option value="vp8">VP8 (WebM)</option>
            <option value="vp9">VP9 (WebM)</option>
            <option value="h264">H.264 (MP4)</option>
            <option value="av01">AV1 (WebM)</option>
          </select>
        </div>
        
        <div>
          <label>Quality:</label>
          <select id="exportQuality">
            <option value="500000">Low (500 Kbps)</option>
            <option value="1000000" selected>Medium (1 Mbps)</option>
            <option value="2000000">High (2 Mbps)</option>
            <option value="5000000">Very High (5 Mbps)</option>
          </select>
        </div>
        
        <div>
          <label>Resolution:</label>
          <select id="exportResolution">
            <option value="original" selected>Original</option>
            <option value="1920x1080">1080p</option>
            <option value="1280x720">720p</option>
            <option value="854x480">480p</option>
            <option value="640x360">360p</option>
          </select>
        </div>
        
        <div>
          <label>Frame Rate:</label>
          <select id="exportFps">
            <option value="original" selected>Original</option>
            <option value="60">60 fps</option>
            <option value="30">30 fps</option>
            <option value="24">24 fps</option>
          </select>
        </div>
      </div>
      
      <button onclick="exportVideo()" id="exportBtn" disabled>üíæ Export Video</button>
      <div id="export-status"></div>
    </div>
  </div>

  <!-- Media Info Tab -->
  <div id="info-tab" class="tab-content">
    <div class="test">
      <h2>Media Information</h2>
      <div id="mediaInfo" class="file-info">
        <p style="color: #666;">Upload a video to see media information</p>
      </div>
    </div>
  </div>

  <!-- Basic Tests Tab -->
  <div id="basic-tab" class="tab-content">
    <div class="test">
      <h2>Backend Health Check</h2>
      <button onclick="testHealth()">Run Test</button>
      <div id="health-status"></div>
    </div>

    <div class="test">
      <h2>Encode Test Frame</h2>
      <canvas id="canvas" width="320" height="240"></canvas>
      <br>
      <button onclick="testEncode()">Encode Frame to VP8</button>
      <div id="encode-status"></div>
    </div>
  </div>

  <script>
    const BACKEND = 'http://localhost:3001';
    let uploadedFile = null;
    let videoMetadata = {};

    function switchTab(tab) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      event.target.classList.add('active');
      document.getElementById(tab + '-tab').classList.add('active');
    }

    function setStatus(id, msg, type) {
      const el = document.getElementById(id);
      if (el) el.innerHTML = `<div class="status ${type}">${msg}</div>`;
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function formatBytes(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
      return (bytes / 1024 / 1024).toFixed(2) + ' MB';
    }

    // File Upload
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
    });
    fileInput.addEventListener('change', (e) => {
      if (e.target.files[0]) handleFile(e.target.files[0]);
    });

    async function handleFile(file) {
      uploadedFile = file;
      setStatus('upload-status', 'Analyzing video...', 'pending');

      // Load video to get metadata
      const video = document.createElement('video');
      video.src = URL.createObjectURL(file);
      
      video.onloadedmetadata = () => {
        videoMetadata = {
          duration: video.duration,
          width: video.videoWidth,
          height: video.videoHeight,
          size: file.size,
          type: file.type,
          name: file.name
        };

        // Update media info
        document.getElementById('mediaInfo').innerHTML = `
          <table>
            <tr><td>Filename:</td><td>${file.name}</td></tr>
            <tr><td>Size:</td><td>${formatBytes(file.size)}</td></tr>
            <tr><td>Type:</td><td>${file.type}</td></tr>
            <tr><td>Duration:</td><td>${formatTime(video.duration)}</td></tr>
            <tr><td>Resolution:</td><td>${video.videoWidth} √ó ${video.videoHeight}</td></tr>
            <tr><td>Aspect Ratio:</td><td>${(video.videoWidth / video.videoHeight).toFixed(2)}</td></tr>
          </table>
        `;

        // Enable buttons
        document.getElementById('thumbBtn').disabled = false;
        document.getElementById('playBtn').disabled = false;
        document.getElementById('trimBtn').disabled = false;
        document.getElementById('exportBtn').disabled = false;
        document.getElementById('startRange').disabled = false;
        document.getElementById('endRange').disabled = false;

        // Setup preview
        const videoPreview = document.getElementById('videoPreview');
        videoPreview.src = video.src;
        videoPreview.style.display = 'block';

        // Update trim controls
        document.getElementById('endTime').textContent = formatTime(video.duration);
        document.getElementById('startRange').max = video.duration;
        document.getElementById('endRange').max = video.duration;
        document.getElementById('endRange').value = video.duration;

        setStatus('upload-status', `‚úÖ Video loaded: ${file.name}`, 'success');
      };
    }

    // Generate Thumbnails
    async function generateThumbnails() {
      if (!uploadedFile) return;
      setStatus('preview-status', 'Generating thumbnails...', 'pending');

      const video = document.createElement('video');
      video.src = URL.createObjectURL(uploadedFile);
      video.crossOrigin = 'anonymous';
      
      await new Promise(resolve => {
        video.onloadedmetadata = resolve;
      });

      const grid = document.getElementById('thumbnailGrid');
      const timelineThumbs = document.getElementById('timelineThumbs');
      grid.innerHTML = '';
      timelineThumbs.innerHTML = '';

      const count = 8;
      const interval = video.duration / count;

      for (let i = 0; i < count; i++) {
        const time = i * interval;
        video.currentTime = time;
        
        await new Promise(resolve => {
          video.onseeked = resolve;
        });

        // Grid thumbnail
        const canvas = document.createElement('canvas');
        canvas.width = 160;
        canvas.height = 90;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        const thumb = document.createElement('div');
        thumb.className = 'thumbnail';
        const thumbCanvas = canvas.cloneNode(true);
        thumbCanvas.getContext('2d').drawImage(video, 0, 0, 160, 90);
        thumb.appendChild(thumbCanvas);
        
        const timeDiv = document.createElement('div');
        timeDiv.className = 'thumbnail-time';
        timeDiv.textContent = formatTime(time);
        thumb.appendChild(timeDiv);
        
        thumb.onclick = () => {
          document.getElementById('videoPreview').currentTime = time;
        };
        grid.appendChild(thumb);

        // Timeline thumbnail
        const timelineCanvas = document.createElement('canvas');
        timelineCanvas.width = 160;
        timelineCanvas.height = 80;
        const timelineCtx = timelineCanvas.getContext('2d');
        timelineCtx.drawImage(video, 0, 0, timelineCanvas.width, timelineCanvas.height);
        timelineThumbs.appendChild(timelineCanvas);
      }

      // Setup timeline scrubber
      setupTimelineScrubber(video);

      setStatus('preview-status', `‚úÖ Generated ${count} thumbnails`, 'success');
    }

    function setupTimelineScrubber(video) {
      const timeline = document.getElementById('timeline');
      const preview = document.getElementById('timelinePreview');
      const previewCanvas = preview.querySelector('canvas');
      const previewTime = document.getElementById('previewTime');
      const previewCtx = previewCanvas.getContext('2d');

      timeline.addEventListener('mousemove', async (e) => {
        const rect = timeline.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percent = x / rect.width;
        const time = percent * video.duration;

        // Position preview
        preview.style.left = `${x}px`;
        preview.style.display = 'block';
        previewTime.textContent = formatTime(time);

        // Draw frame
        video.currentTime = time;
        await new Promise(resolve => {
          video.onseeked = resolve;
        });
        previewCtx.drawImage(video, 0, 0, 160, 90);
      });

      timeline.addEventListener('mouseleave', () => {
        preview.style.display = 'none';
      });

      timeline.addEventListener('click', (e) => {
        const rect = timeline.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const percent = x / rect.width;
        const time = percent * video.duration;
        document.getElementById('videoPreview').currentTime = time;
      });
    }

    function playPreview() {
      document.getElementById('videoPreview').play();
    }

    // Trim Video
    document.getElementById('startRange').oninput = (e) => {
      const val = e.target.value;
      document.getElementById('startTime').textContent = formatTime(val);
      document.getElementById('startMarker').style.left = (val / videoMetadata.duration * 100) + '%';
    };

    document.getElementById('endRange').oninput = (e) => {
      const val = e.target.value;
      document.getElementById('endTime').textContent = formatTime(val);
      document.getElementById('endMarker').style.left = (val / videoMetadata.duration * 100) + '%';
    };

    async function trimVideo() {
      if (!uploadedFile) return;
      
      const start = parseFloat(document.getElementById('startRange').value);
      const end = parseFloat(document.getElementById('endRange').value);
      
      setStatus('trim-status', `Trimming video from ${formatTime(start)} to ${formatTime(end)}...`, 'pending');
      
      try {
        const formData = new FormData();
        formData.append('video', uploadedFile);
        formData.append('codec', 'h264'); // Use H.264 for MP4
        formData.append('bitrate', '2000000');
        formData.append('start', start.toString());
        formData.append('end', end.toString());

        const res = await fetch(`${BACKEND}/encode`, {
          method: 'POST',
          body: formData
        });

        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.error || 'Encoding failed');
        }

        const blob = await res.blob();
        
        // Download the trimmed video
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `trimmed_${uploadedFile.name}`;
        a.click();
        URL.revokeObjectURL(url);

        setStatus('trim-status', `‚úÖ Video trimmed and downloaded!<br>
          Duration: ${formatTime(end - start)}<br>
          Size: ${formatBytes(blob.size)}`, 'success');
      } catch (e) {
        setStatus('trim-status', `‚ùå Error: ${e.message}`, 'error');
      }
    }

    // Export Video
    async function exportVideo() {
      if (!uploadedFile) return;

      const codec = document.getElementById('exportCodec').value;
      const bitrate = document.getElementById('exportQuality').value;
      const resolution = document.getElementById('exportResolution').value;
      const fps = document.getElementById('exportFps').value;

      setStatus('export-status', `Exporting video with ${codec} codec...`, 'pending');

      try {
        const formData = new FormData();
        formData.append('video', uploadedFile);
        formData.append('codec', codec);
        formData.append('bitrate', bitrate);
        formData.append('resolution', resolution);
        formData.append('fps', fps);

        const res = await fetch(`${BACKEND}/encode`, {
          method: 'POST',
          body: formData
        });

        const blob = await res.blob();
        
        // Download the exported video
        const ext = codec === 'h264' ? 'mp4' : 'webm';
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `exported_${codec}_${uploadedFile.name.split('.')[0]}.${ext}`;
        a.click();
        URL.revokeObjectURL(url);

        setStatus('export-status', `‚úÖ Video exported and downloaded!<br>
          Codec: ${codec.toUpperCase()}<br>
          Bitrate: ${(bitrate / 1000000).toFixed(1)} Mbps<br>
          Size: ${formatBytes(blob.size)}`, 'success');
      } catch (e) {
        setStatus('export-status', `‚ùå Error: ${e.message}`, 'error');
      }
    }

    // Basic Tests
    async function testHealth() {
      setStatus('health-status', 'Testing...', 'pending');
      try {
        const res = await fetch(`${BACKEND}/health`);
        const data = await res.json();
        setStatus('health-status', 
          `‚úÖ Backend: ${data.status}, WebCodecs: ${data.webcodecs}`, 'success');
      } catch (e) {
        setStatus('health-status', `‚ùå Error: ${e.message}`, 'error');
      }
    }

    async function testEncode() {
      setStatus('encode-status', 'Generating frame...', 'pending');
      
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createLinearGradient(0, 0, 320, 240);
      gradient.addColorStop(0, '#ff0000');
      gradient.addColorStop(1, '#0000ff');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 320, 240);
      ctx.fillStyle = 'white';
      ctx.font = '30px Arial';
      ctx.fillText('WebCodecs', 80, 120);

      const yuv = new Uint8Array(320 * 240 * 3 / 2);
      yuv.fill(128);

      setStatus('encode-status', 'Encoding...', 'pending');

      try {
        const formData = new FormData();
        formData.append('frames', new Blob([yuv]));
        formData.append('width', '320');
        formData.append('height', '240');
        formData.append('codec', 'vp8');

        const res = await fetch(`${BACKEND}/encode`, {
          method: 'POST',
          body: formData
        });

        const blob = await res.blob();
        setStatus('encode-status', 
          `‚úÖ Encoded ${blob.size} bytes to VP8`, 'success');
      } catch (e) {
        setStatus('encode-status', `‚ùå Error: ${e.message}`, 'error');
      }
    }

    // Auto-run health check
    window.onload = () => testHealth();
  </script>
</body>
</html>
